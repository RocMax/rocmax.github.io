{"pages":[{"url":"http://blog.game18.net/posts/2015/10/geng-huan-bo-ke-zhu-ti/","text":"刚弄好的博客突然间挂掉了.运行 make html 的时候所有md文件都报 OSError: [Errno 2] No such file or directory. 分明之前还好好的.分析了一下traceback,发现问题出在 extract_toc 插件.在elegant主题作者的 博客 上可以看到左边有一个 Contents 栏,可以在页面中定位文章的条目,从而方便地在内容之间跳转,很好的一个功能.作者的博客中说要使用这个功能的话需要引入 extract_toc 插件. 顺便说一句需要看Pelican的log,使用 pelican -D -s pelicanconf.py content -o output 而不是make html来运行Pelican 在插件列表中添加 extract_toc 后就出现上面的错误,即使把其他插件都删除只剩 extract_toc 还是会报错.看了一下 extract_toc 的 代码 ,发现这么一段: try : from pandoc_reader import PandocReader except ImportError : PandocReader = False `` ` [ 代码 ]( https : // github . com / getpelican / pelican - plugins / tree / master / extract_toc ) 看来这个插件还擅自引用了 `pandoc_reader` 这个插件 . 查看其 [ 代码 ]( https : // github . com / liob / pandoc_reader ): `` ` Python proc = subprocess . Popen ( pandoc_cmd , stdin = subprocess . PIPE , stdout = subprocess . PIPE ) 这里运行时报错,在stackoverflow上有很多类似的问题,subprocess.Popen经常会引起 raise child_exception 然后 No such file or directory. 从他们的讨论内容看来似乎是PATH方面的问题. 如果在 extract_toc 中忽略对 pandoc_reader 的检查直接返回False的话是可以避免报错,但是返回给Pelican的toc仍然是None,在Pelican代码中有个检测,toc为None的时候Content不显示,所以添加 extract_toc 也就没有意义了. 我顺着报错的地方看了一些源码,但还是搞不明白原因.elegant这种用户很多的theme按说出了bug应该会有很多人反映,而且据说elegant的作者更新也很勤快.所以我感觉应该是我的配置或者环境有些问题.在 这里 博主也有提到: plugin的执行顺序是随机的（坑爹），所以最好不要有相互依赖的关系 之后有时间继续研究一下这个问题吧.当务之急是让把博客恢复起来.我把官方Git上的所有主题截图都浏览过,喜欢的并不多,有几个虽然看起来很漂亮,但又有点过于文艺范.后来我发现很多博客都在用 pelican-bootstrap3 主题,风格比较简约适合技术博客. 按着readme配置了一下,发现这个主题可配置的地方很多,功能比较完善.我最喜欢的是可定制的顶部banner,用了黑猫的图片加上黑白配色,堪称完美. 于是Bolg满血复活,测试了几次没发现什么bug,暂且先用这个主题好了.以后研究一下自己学着定制主题吧.","tags":"Python","title":"更换博客主题"},{"url":"http://blog.game18.net/posts/2015/10/li-yong-pelicanhe-github-pagesda-zao-ge-xing-hua-bo-ke-er/","text":"在上一篇里我们已经完成了Pelican的安装,生成网站并部署到GitHub Pages上.下面我们就继续完善网站的设置. 1. 更换主题 目前我们的网站使用默认主题,不是很漂亮,功能也单一,我们首先更换主题.运行: git clone --recursive https://github.com/getpelican/pelican-themes.git 会把所有主题下载到本地,注意使用--recursive参数,否则很多链接的主题只能获取到空文件. 下一步安装主题,有两种方法,在上面的git中提到可以在pelicanconf.py配置文件中指定主题存放路径,如下: THEME = \".../Blog/pelican-themes/theme-name\" 我使用了另一种方法,在pelican-themes文件夹下运行: pelican-themes -i .../Blog/pelican-themes/theme-name 这条命令可以把主题安装到 /Library/Python/2.7/site-packages/pelican/themes 下,然后在配置文件中直接指定主题名即可: THEME = \"theme-name\" 重新 make html ,查看一下是不是已经应用了新的主题. 主题虽然改了,但很多功能还没法使用,我们还需要进行很多配置. 2. 安装插件 插件可以扩展Pelican的功能,很多主题也需要依赖插件运行.和主题的安装一样,首先将插件包下载到本地: git clone --recursive https://github.com/getpelican/pelican-plugins 然后在配置文件中设置插件路径和名称列表: PLUGIN_PATHS = [ 'pelican-plugins' ] PLUGINS = [ 'assets' , 'sitemap' , 'gravatar' ] 简单介绍几个正在用的插件: sitemap 生成sitemap.xml,帮助搜索引擎抓取网站内容.除了添加进插件列表意外,还需要添加一些设置: SITEMAP = { \"format\" : \"xml\" , \"priorities\" : { \"articles\" : 0.7 , \"indexes\" : 0.5 , \"pages\" : 0.3 , }, \"changefreqs\" : { \"articles\" : \"monthly\" , \"indexes\" : \"daily\" , \"pages\" : \"monthly\" , } } render_math 让Pelican支持数学公式,由 MathJax 引擎提供支持,公式语法和LaTex相似,尝试一下: $$E = mc&#94;2$$ tag_cloud 提供 标签云 ,除了显示Tags以外,会按文章数目区分显示不同的标签.这个功能原本是集成在Pelican中的,后来被拿出来作为插件,于是一些旧的主题如果不装这个插件的话标签列表无法显示,例如我尝试使用过的 foundation-default-colours ,安装这个插件就可以解决问题. gzip_cache 将页面压缩为gz格式,提高加载速度. 另外,有些主题需要特定插件的支持,例如我现在用的 elegant 需要安装 extract_toc , tipue_search ,总之查看主题和插件的Readme,自己决定安装哪些插件. 3. 修改配置文件 接下来我们要修改Pelican的配置文件 pelicanconf.py ,这里包含非常多的条目,详细的介绍参见 这里 ,我简单介绍其中几项: 日期格式 DEFAULT_LANG = u'zh' DATE_FORMATS = {'zh' : '%Y-%m-%d(%a)'} 默认的日期格式比较适合国外的习惯,上面两句可以把日期格式改为年-月-日(星期)这样比较适合国人习惯的格式. 文件路径 STATIC_PATHS=[\"imgs\",\"extra\"] EXTRA_PATH_METADATA = { 'extra/CNAME': { 'path': 'CNAME' }, 'extra/favicon.ico': { 'path': 'favicon.ico' }, 'extra/robots.txt': { 'path': 'robots.txt' }, } 我在content目录下建了两个目录 imgs 用来存放图片, extra 里存放了 CNAME,favicon.ico,robots.txt 三个文件.上面两句把imgs文件夹和extra里的三个文件原封不动拷贝到output目录下(注意:imgs是文件夹拷贝,另外三个文件直接拷贝).博文中可以直接使用 ![text](/imgs/filename.jpeg) 这样的链接来引用本地图片.另外三个文件作用分别是: CNAME:解析域名用,后面会说到. favicon.ico:让网页标签中显示图标,像这样 robots.txt:告诉搜索引擎爬虫此网站中的哪些内容不应被搜索引擎获取，哪些可以被获取,写法可以参考 这里 . 文件保存配置 一些主题会要求配置特定的项目,elegant主题推荐如下配置: MD_EXTENSIONS = [ 'codehilite(css_class=highlight)' , 'extra' , 'headerid' , 'toc' ] DIRECT_TEMPLATES = (( 'index' , 'tags' , 'categories' , 'archives' , 'search' , '404' )) TAG_SAVE_AS = '' CATEGORY_SAVE_AS = '' AUTHOR_SAVE_AS = '' 参考官方配置文档可以发现有很多 xxxx_SAVE_AS 的配置项,控制各类页面保存方式,可以使用 {slug} 变量用来获取md文件中的Slug字段.Pelican在保存页面的时候会生成一个文件名,文章名是中文如 随笔 的话会生成类似 sui-bi.html 的文件,同时会过滤掉一些不适合放在路径和文件名中的空格和其他符号.于是带来一个问题,在某些主题中如果添加 C++ 标签的话,保存时会忽略 ++ 生成类似于 ~/tags/c.html 的路径,但是在页面链接中点击 C++ 的tag,网页仍会尝试转向 ~/tags/C++.html 页面,于是报错.elegant主题倒没有这个问题,以后自己定制主题的时候要注意这一点. 其他功能配置: 评论:利用Disqus实现评论功能,只需在配置中添加 DISQUS_SITENAME=\"yoursitename\" Google Analytcs:在配置中添加 GOOGLE_ANALYTICS=\"UA-xxxxxx-xxxx\" 友情链接和社交链接:参照 这里 填写配置文件相关项目 4. Tips 删除线 不是MarkDown的标准语法,使用 ~~ 语法不会被转化为删除线效果,这种情况下可直接使用 <s>删除线</s> . 新建md文件时总是需要在开头写meta data,比较繁琐,我写了一个sh脚本来创建新的md文件,代码如下: #!/bin/sh datetime = $( date +%Y-%m-%d \\ %H:%M:%S ) filename = $( date +%Y%m%d_%H_%M_%S ) echo \"Title: \\nDate: ${ datetime } \\nModified: \\nCategory: \\nTags: \\nSlug: \\nAuthors: \\nSummary: \\nStatus: draft\" >../content/ ${ filename } .md 这样可以自动使用当前日期和时间创建新md文件,而且meta data项目已经都添加好.如果觉得打开shell运行脚本比较麻烦,也可以使用Automator打包成可执行文件(OSX系统).另外,虽然利用 publishconf.py 中的设定可以完成GitHub上传,我还是写了一个脚本完成上传工作: #!/bin/sh commitstr = $( date +%Y%m%d_%H_%M_%S ) cd /Users/lipeng/Documents/Blog make html cd /Users/lipeng/Documents/Blog/output git add . git commit -m ${ commitstr } git push origin master 在脚本中使用 date 获取系统时间,可以确保不会重名,而且上传到GitHub中的commit信息也比较容易识别.我把脚本都扔在tools文件夹中. 使用自己的域名 如果觉得GitHub.io域名不够个性的话,也可以把网站挂在自己的域名下.具体做法是: 在网站根目录新建一个 CNAME 文件(文件名大写,无扩展名),文件中填写域名,我的这个文件中写 blog.game18.net ,将这个文件放在 content/extra 下,按照我们在 这里 的设置, CNAME 文件会被自动拷贝至网站根目录. 登陆域名管理页面,在DNS设定中添加一项: 如果需要做TYPE A设置,参考 这里 将网站同步至GitHub,在根目录下看到 CNAME 文件后,检查Settings页面,应该已显示新域名: 等待几分钟DNS设置生效后即可从新域名访问博客,是不是很酷? 到这里,博客的一些基本设置就完成了,Enjoy your own Blog! if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"Python","title":"利用Pelican和GitHub Pages打造个性化博客(二)"},{"url":"http://blog.game18.net/posts/2015/10/li-yong-pelicanhe-github-pagesda-zao-ge-xing-hua-bo-ke-yi/","text":"1. 配置GitHbu Pages 在GitHub中新建一个repository,命名为username.github.io,其中username是github的用户名,我建的是rocmax.github.io. 进入后点击右边栏中的Settings,找到GitHub Pages栏,点击Launch automatic page generator按钮,然后点击Continue to layouts,选择一个主题样式,点击Publish page,一个崭新的GitHub Pages页面就出现了,你可以使用username.github.io访问这个新页面,是不是很酷? 网页虽然能访问了,但离想要的博客还很遥远.当然,直接去编辑html文件可以改变网页内容,我们显然不会采用这种笨办法.我们先把自动生成的文件都删除(不熟悉Git命令的话可以在网页上挨个删掉然后commit,git命令下面会涉及到) 2. 安装Pelican 我的系统环境: OSX Python Git 10.11 2.7.10 2.3.8 使用pip安装Pelican和MarkDown pip install pelican pip install markdown 如果安装时报Permission denied,在命令前加sodu,运行时可能需要输入系统密码. 在磁盘上新建一个文件夹用来存放本地文件,比如我的文件夹叫Blog,然后运行: cd Blog pelican-quickstart 如果你跟我的环境一样的话 from six.moves.html_parser import HTMLParser 这句代码会报错,在six.moves里找不到html_parser.看来出了一些问题,处理之前我们先卸载Pelican pip uninstall pelican . 网上有一种处理方法是把这句代码改为 from HTMLParser import HTMLParser 实测可以解决. 我在网上找到另一种解释说是因为six的版本过低导致,使用 pip install -U six 可以fetch到新版本但是安装报错,加sudo都不让装,好像说是因为six这个组件比较核心.我找到的解决方法是到 这里 下载six的whl格式安装文件可以正常安装. 然后重新安装Pelican,在Blog下运行 pelican-quickstart ,它会问一些问题,按自己喜好回答或者在 这里 找答案,系统会按照答案生成一些配置,以后可以改所以怎么填都行,完成后会在目录下生成很多文件. 这就是Blog下的文件列表: 解释一下其中的部分内容(有些文件是后面加入的): content 存放md文件 develop_server.sh 控制本地网页服务器 Makefile 生成网站 output 存放生成的网站,之后这个文件夹会被同步到GitHub pelican-plugins 插件目录 pelican-themes 主题目录 pelicanconf.py 配置文件 publishconf.py 发布配置文件 tools 我自己加的,后面再讲 到这里安装就基本完成了. 3. 开始写博客 编写一个md文件,在最前边需要添加一些信息,下面是一个例子: Title : My super title #文章标题 * Date : 2010 - 12 - 03 10 : 20 #编写时间 * Modified : 2010 - 12 - 05 19 : 30 #修改时间 Category : Python #类别 * Tags : pelican , publishing #标签 * Slug : my - super - post #翻译不能 , 链接地址字符串 , 可以用来处理文章不同语言版本 Authors : Alexis Metaireau , Conan Doyle #作者 Summary : Short version for index and feeds #摘要 Hello world !...... 加*的是必填项 写完后放到content目录下,然后在Blog文件夹下执行 make html 生成网站.可以看到output目录下已经存放了生成好的文件. 然后继续运行 make devserver 开启网页服务,浏览器访问http://localhost:8000 即可看到生成的网页了,而且文件更改后还可以实时重新生成.用完以后记得 make stopserver 关闭服务. 4. 将网站部署到GitHub Pages 最后一步,将生成的网站部署到GitHub Pages,这一步需要使用一些Git命令,不熟悉的话请参考 这里 . 在终端里进入output目录,执行下列命令: git init #创建Git仓库 git add . #将output下的所有文件加入仓库 git remote add origin https://github.com/username/username.github.io #添加远程仓库,可能会要求输入Github用户名和密码 git pull origin master #将远程仓库中的文件获取回本地,之前已经都删除了,不会获取任何文件,不这样的话之后提交会冲突 git commit -m 'first update' #提交一个更改,命名为\"first update\" git push origin master #将本地更改同步到远程仓库的master分支 运行完成的话博客就上传到GitHub了,可以登陆username.github.io看一下,应该跟上一步最后看到的网页一样. 总结 到这里就把使用Pelican+GitHub Pages搭建个人博客的基本流程介绍完了.生成的博客应该类似于这样: 呃....好像也很丑的样子,而且也没啥功能. 下一篇我们继续定制这个博客,让它变得既美观又功能强大.","tags":"Python","title":"利用Pelican和GitHub Pages打造个性化博客(一)"},{"url":"http://blog.game18.net/posts/2015/10/zhu-xin-bo-ke-kai-zhang/","text":"生命在于折腾! 不久前刚刚开始使用 Blogger ,为了替换一直使用的印象笔记.用了一段时间发现还是不爽,Blogger对MarkDown的支持并不是太好,也没什么好用的编辑器去配合,而且我费半天劲定制的Blogger界面丑得要死.终于,我下定决心再折腾一遍,搞一个更好用的博客. 上网搜一搜,什么博客比较高大上呢?知乎马上给你答案: GitHub Pages ,GitHub推出了支持静态网页的功能,就是GitHub Pages,程序员当然要用GitHub才算专业嘛.我们现在有md文件写博客内容,只要能把它们转成网页然后发布到GitHub Pages上就大功告成了.在GitHub Pages页面上推荐了 Jekyll 应该是最有名的静态博客网站转换工具.但Jekyll是基于Ruby的,我不懂也不想学,于是我选择了基于Python的 Pelican 来完成这项工作. 经过三天的研究, 新博客 终于上线了,本篇是随笔所以不写太多技术内容,下一篇详细写搭建流程吧. 最后,感谢神奈提供的域名,让博客的 B格 更加提高了一点(刚明明说用GitHub才叫专业).感谢 Talha Mansoor 开发的 Elegant 主题,试过了n多个主题以后,发现Elegant果然是当之无愧的 best-pelican-theme .我自己也研究了一下Pelican的主题开发,似乎难度并不高,以后有时间自己也弄一套吧.另外,感谢Pelican,感谢Python......","tags":"随笔","title":"祝!新博客开张!"}]}