{"pages":[{"url":"http://blog.game18.net/posts/2016/03/da-jian-jie-shi-ban/","text":"近日，神奈同学说需要做一个揭示板。起因是神奈在日本经常各处旅游，途中发现很多日本人开的商店为了吸引中国游客会做一些中文的招牌。由于语言不通，招牌文字只能借助google翻译，翻译质量可想而知。语句不通就罢了，很多时候还会闹笑话甚至造成误解。为了给店家提供帮助，同时也为了方便中国游客，神奈同学决定使用揭示板帮助翻译招牌。 我觉得这是一项很有意义的活动，于是接下了搭建揭示板的任务。在这里把搭建过程记录一下。 关于揭示板 神奈的需求是告诉店家一个地址让他把要翻译的日语贴上来，神奈翻译好后回帖，对方就可以复制去排版打印。这次选择的揭示板是由KENT开发的 YY-BORD ,相较于bbs来说更加轻量级，不需要配置数据库，而且完全可以满足需求。 网页服务 正好手头有一台樱花的VPS（架设了VPN，科学上网你懂的），我看了一下后台，日常负荷并不重，所以打算利用一下剩余价值。VPS安装的是CentOS系统，首先安需要装网页服务Apache，安装后开启服务，具体的配置后面细说。正常开启服务后用浏览器访问服务器IP会返回Apache的介绍页面，证明服务正常。 FTP服务 为了方便网站日常管理，需要在服务器上配置FTP服务，我用的是vsftpd。yum安装后需要配置 vsftpd.conf ,配置方法可以参考 鳥哥的 Linux 私房菜 。下面讲解下每一项的含义： anonymous_enable = NO #禁止匿名登录 local_enable = YES #本地用户可登录，例如ftp账户 write_enable = YES #可写 local_umask = 022 #新建目录拥有（777-022=755）新建文件拥有（666-022=644）权限 anon_upload_enable = NO #禁止匿名用户上传 anon_mkdir_write_enable = NO #禁止匿名用户写入/创建目录 dirmessage_enable = YES #如果目录下有.message文件则显示其内容 xferlog_enable = YES #启用日志记录 connect_from_port_20 = YES #支持主动式连接 xferlog_file = /var/log/xferlog #日志存放路径 nopriv_user = nobody #预设以nobody为ftp服务的执行者 ascii_upload_enable = YES #允许ASCII模式上传 ascii_download_enable = YES #允许ASCII模式下载 ftpd_banner = FTP service for yybord,Welcome! #欢迎信息 chroot_local_user = YES #将本地用户限制下ftp目录内，无法访问以外的目录 chroot_list_enable = YES #使用不被chroot的用户列表 chroot_list_file = /etc/vsftpd/chroot_list #此列表中的用户不受chroot限制，即使不写也要存在一个此名字的空文件 listen = YES #以standalone的方式启动ftp pam_service_name = vsftpd #服务名 userlist_enable = YES #使用user_list限制用户登陆 userlist_deny = NO #设置列表中的用户作为允许用户（白名单） userlist_file = /etc/vsftpd/user_list #用户列表文件 use_localtime = YES #使用本地时间 tcp_wrappers = YES #支持TCP wrappers，（那是什么？） local_root = /var/www/ #本地用户登录时的根目录，设置为网页服务器的根目录 最后使用service vsftpd start开启ftp服务。（也可以加入开机启动，这次仅仅为了上传网站数据，需要用的时候自己开比较安全。） 尝试过使用wget直接从互联网下载网页文件，但这样下载的文件无法运行。实际上FTP有两种上传模式：ASCII和Binary。ASCII模式会转换一些符号例如回车来适应不同的平台，Binary模式会上传二进制文件并保证上传的文件与本地文件相同。 部署揭示板 准备工作完成，正式开始部署揭示板。从 这里 下载揭示板程序，它是使用Perl编写的cgi程序。 使用FTP客户端上传至 cgi-bin 目录下， .cgi 、 .pl 、 .html 等代码文件需要使用ASCII模式上传， .png 、 .ttf 等文件需要使用Binary模式上传。 接着对http服务进行一些必要的配置，使其能够运行cgi文件。打开 /etc/httpd/conf/httpd.conf 配置以下项目： LoadModule cgi_module modules/mod_cgi.so #载入cgi模块 ScriptAlias /cgi-bin/ \"/var/www/cgi-bin/\" #指定可以运行cgi的目录 <Directory \"/var/www/cgi-bin\" > #对cgi运行目录进行配置 AllowOverride None Options ExecCGI #允许执行cgi AddHandler cgi-script .pl .cgi #添加执行各种文件的Handler AddHandler text/css .css AddHandler text/javascript .js AddHandler text/html .html AddHandler image/png .png AddHandler image/gif .gif Order allow,deny Allow from all </Directory> 另外，还有两个软件包需要安装： perl-CGI 解决 use CGI::Carp qw(fatalsToBrowser); 报错问题 ImageMagick-perl 提供图片验证码功能 之后 service httpd restart 重启http服务。按照 这里 的说明配置文件的访问权限，然后使用浏览器访问 check.cgi 如果没有 NG 表明全部配置OK。 但是在这里我遇到一个诡异的问题，就是在访问 yybbs.cgi 时总是显示 Write Error: ./data/count.dat ，即使把 count.dat 的权限设置为777仍无法写入。这个问题困扰了我好久，最终我发现罪魁祸首是 SELinux ，网上有如何设置 SELinux 的介绍，但是大多数人估计会选择关掉它。修改 /etc/selinux/config ，将 SELINUX=enforcing 改为 ELINUX=disabled 重启服务器，揭示板终于可以正常运行了。 注意事项 打开http服务之后，总是会有人采用各种方式攻击服务器，比如利用cgi漏洞获取管理员账户等。为了防止被攻陷，需要按照网上的资料配置各种安全措施。对于一直尝试攻击的地址索性使用iptables屏蔽掉，比如下面这些： iptables -A INPUT -s 89.248.160.132 -j DROP iptables -A INPUT -s 61.160.213.32 -j DROP iptables -A INPUT -s 61.160.213.55 -j DROP iptables -A INPUT -s 61.160.213.56 -j DROP iptables -A INPUT -s 61.160.213.247 -j DROP iptables -A INPUT -s 137.226.113.7 -j DROP iptables -A INPUT -s 91.196.50.33 -j DROP iptables -A INPUT -s 119.188.4.3 -j DROP iptables -A INPUT -s 168.160.249.233 -j DROP iptables -A INPUT -s 210.56.209.98 -j DROP 大功告成 最后，欢迎访问 揭示板 ,顺便挂到博客的域名下，但神奈说这个域名像骗钱的，之后会换个新域名(我感觉被猛烈地鄙视了。。。)。 总之，希望这个项目能成功运行，并给更多的人提供帮助。","tags":"网页技术","title":"搭建揭示板"},{"url":"http://blog.game18.net/posts/2016/03/guan-yu-vryou-xi-de-tao-lun/","text":"好久没有更新博客了,从去年12月开始一直在忙业务系统上线的事情.期间写了两三篇跟技术无关的文字,今天想了想还是都删掉了.我决定保持这里的纯洁性,随笔栏目里只记录技术相关的想法,无关的东西可以扔去微博或者twitter. 前几天跟神奈同学聊天时对VR技术在游戏中的应用问题争论了一番,我俩的意见分歧还是挺大的。后来我在听一个讨论式的播客（IT公论）时想到：不如把这部分内容记录一下，以后再回头看看谁的预测比较准确，应该是一件很有趣的事情。 关于VR 当前VR技术可以说是最火热的科技话题，各大IT公司纷纷投入到这一领域中。实际上VR不是一个新概念，只是随着科技的进步设备实现小型化，也就具备了普及给大众使用的条件。 VR设备通过向使用者提供视觉、听觉、触觉等方面的感官信息从而营造一种身临其境的体验。可以说临场感是VR相较于传统人机界面的最大进步。 关于VR游戏的分歧 我和神奈在VR游戏中视角运用方面分歧较大： 我认为VR游戏应该让用户有自由的视角，这才是VR存在的意义。 神奈认为VR游戏中除了个别类型以外，仍应由游戏来控制视角。 从预定发售的游戏看来，第二种情况居多，基本上都是保留现有的游戏方式，借助VR提供3D视觉效果，那么VR系统就退化成了穿戴式3D显示器。我认为VR更重要的是交互方式的改进，现在的技术还达不到能让用户穿戴上VR设备后随意移动，而且也很难提供视觉以外的其他感觉反馈。仅仅停留在提供3D视觉和音效的程度，只能说离真正的VR还相去甚远。 VR适合的游戏类型 FPS游戏应该是天然适合使用VR技术的游戏，类似地，第一人称动作类的游戏也很适合。RPG游戏除了非常强调自由度的类型外，基本上会希望玩家按照游戏安排进行，有时候视角的控制是必要的，否则玩家错过了重要的线索会导致游戏难以进行。 这里引出另外一个问题，相对于在显示器上显示的3D效果，VR设备在视角移动时带来的眩晕值异常高。可能视觉反馈越真实，与其他感觉的冲突就越大。从这方面看来，MineCraft的扩增实境反而是更合理的实现方式。","tags":"随笔","title":"关于VR游戏的讨论"},{"url":"http://blog.game18.net/posts/2015/11/cocos2d-xshi-xian-liu-ti-mo-ni-chu-ji-pian/","text":"前一阵在群里讨论的时候说到使用Cocos2d-x做2D水流，我觉得很有挑战性，于是研究了一阵。实际上流体模拟不仅在游戏开发中应用广泛，而且在工程和科研方面也有重要的意义。今天我们就开始探讨如何使用Cocos2d-x实现流体模拟。 这个系列打算分成三个阶段： 初级篇：解决流体模拟中几个基本问题，实现基本的流体效果 中极篇：整合第三方库，实现较好的流体效果 高级篇：自己编写相关功能，理解原理和算法 这次先完成初级篇，中级和高级篇需要等搞定代码之后再写， 尽量别烂尾 。 这次的参考博客： Simulating mud/slime with Box2D, bitmaps and filters ,我们这次要实现和他差不多的效果。 准备工作 流体模拟需要解决两个关键问题：如何动起来像流体；如何看起来像流体。 初级篇中我们使用大量物理刚体粒子模拟流体运动，当然，看着着一堆粒子想象液体运动是不可接受的。针对第二个问题呢，需要使用一些渲染方面的技巧。最终实现的效果参考示例博客，说实话差强人意，初级篇嘛，不要要求太高。 物理引擎 Cocos2d-x自带Box2D和chipmunk两种物理引擎，一般来讲Box2D要强大一些，而chipmunk则比较轻量，不过对于今天的任务选哪个都没差。（Cocos2d-x默认使用chipmunk，需要切换的话可以参考 这里 ） 使用物理引擎时代码和平常有点不同，在创建scene时要这样： auto scene = Scene :: createWithPhysics (); scene -> getPhysicsWorld () -> setDebugDrawMask ( PhysicsWorld :: DEBUGDRAW_ALL ); 使用 createWithPhysics() 创建一个含有物理世界的场景，在之后可以使用 getPhysicsWorld() 获取到物理世界。使用 setDebugDrawMask 设置DebugDraw的模式，物理节点本身没有显示效果，设置为 DEBUGDRAW_ALL 方便查看和调试。 然后使用EdgeBox添加\"桶壁\"，这种物理节点不受重力影响，一般用来当做外框。 auto barrelbody1 = PhysicsBody :: createEdgeBox ( Size ( 10 , 450 )); auto barrelbody2 = PhysicsBody :: createEdgeBox ( Size ( 150 , 10 )); auto barrelbody3 = PhysicsBody :: createEdgeBox ( Size ( 10 , 500 )); auto barrelsp1 = Sprite :: create (); auto barrelsp2 = Sprite :: create (); auto barrelsp3 = Sprite :: create (); barrelsp1 -> setPosition ( Vec2 ( 305 , 685 )); barrelsp2 -> setPosition ( Vec2 ( 375 , 405 )); barrelsp3 -> setPosition ( Vec2 ( 445 , 660 )); barrelsp1 -> setPhysicsBody ( barrelbody1 ); barrelsp2 -> setPhysicsBody ( barrelbody2 ); barrelsp3 -> setPhysicsBody ( barrelbody3 ); addChild ( barrelsp1 ); addChild ( barrelsp2 ); addChild ( barrelsp3 ); Cocos2d-x已经将物理节点封装在Node中，使用Node的 setPhysicsBody 即可添加相应地物理节点。 下面添加物理粒子,使用 schedule 调用 updateParticle 函数，同时限制一下粒子数量，在模拟器中300个以内的粒子基本不会影响帧数。引擎提供了 getAllBodies 函数，可以方便地遍历所有物理节点。 void HelloWorld :: addparticle ( cocos2d :: Vec2 position ){ auto particleBody = PhysicsBody :: createCircle ( 8.0f , bMaterial , Vec2 :: ZERO ); auto particleNode = Node :: create (); particleNode -> setPosition ( position ); particleNode -> setPhysicsBody ( particleBody ); addChild ( particleNode ); nodevector . pushBack ( particleNode ); } void HelloWorld :: updateParticle ( float t ){ if ( nParticle < MAX_PARTICLE_NUM ) { addparticle ( Vec2 ( 373 + CCRANDOM_0_1 () * 5 , 1000 )); nParticle ++ ; nParticleLabel -> setString ( StringUtils :: format ( \"Particle num:%d\" , nParticle )); } for ( auto body : getScene () -> getPhysicsWorld () -> getAllBodies ()) { if ( body -> getNode () -> getPosition (). y < 0 ) { nodevector . eraseObject ( body -> getNode ()); body -> getNode () -> removeFromParentAndCleanup ( true ); nParticle -- ; nParticleLabel -> setString ( StringUtils :: format ( \"Particle num:%d\" , nParticle )); } } } 其中 bMaterial 是粒子的材质，它是一个刚性光滑球，具体数值为： bMaterial . density = 4.0f ; //密度 bMaterial . friction = 0 ; //摩擦力 bMaterial . restitution = 0 ; //弹性 最后，看一下效果，有那么点意思了： 这里我们看到的形状都是 DebugDraw 绘制的，如果把 DEBUGDRAW_ALL 改为 DEBUGDRAW_NONE 则只能看到黑屏。 我们一直没有给物理节点的添加图形是有原因的。物理引擎模拟了物理节点之间的相互作用和运动情况，但我们不能直接将图形绘制在物理节点上，我们需要的只是粒子的位置信息，接下来就利用这些信息解决第二个问题。 流体渲染 从球形的粒子渲染出流体效果需要两步处理：模糊和截断,先把小球模糊成雾状,再对其边缘截断,就可以模拟出液体效果。 模糊 回想一下上一篇博客 高斯模糊 ,我们是不是可以按照同样的方法进行模糊呢?答案是不能。在那篇博客中提到了高斯模糊比较消耗系统资源，如果使用相同的方法帧数会大幅下降。 实际上，那篇博客中提到的方法适用于不知道运行时要模糊什么图像的情况。而当前问题中我们很明确就是要模糊小球嘛，于是直接准备模糊好的素材就行啦： 模糊前： 模糊后: 那么,现在效果变成了这样（关掉了DEBUGDRAW）: 截断 上面的图形依然不是最终结果，所以不能直接渲染在屏幕上。我们可以先把模糊过的小球渲染在RenderTexture中，然后取出整个图像进行截断，再将结果渲染在屏幕上。 首先创建RenderTexture并取出素材渲染到屏幕： rt = RenderTexture :: create ( winsize . width , winsize . height ); rt -> retain (); rtsp = ShaderSprite :: createWithTexture ( rt -> getSprite () -> getTexture (), Rect ( 0 , 0 , winsize . width , winsize . height ), 0.1f ); rtsp -> setPosition ( Vec2 ( winsize . width / 2 , winsize . height / 2 )); 注意其中使用了ShaderSprite,正是在 高斯模糊 中自定义的类,只是修改了传参，使用的着色器代码为: #ifdef GL_ES precision mediump float ; #endif varying vec4 v_fragmentColor ; varying vec2 v_texCoord ; uniform float limit ; void main () { if ( texture2D ( CC_Texture0 , v_texCoord ). b > limit ) { gl_FragColor = vec4 ( 0 , 1 , 0 , 1 ); } } 很容易理解，将输入图片中蓝色值大于limit的渲染为绿色，其余丢弃。 改写 updateParticle 函数： void HelloWorld :: updateParticle ( float t ){ if ( nParticle < MAX_PARTICLE_NUM ) { addparticle ( Vec2 ( 373 + CCRANDOM_0_1 () * 5 , 1000 )); nParticle ++ ; nParticleLabel -> setString ( StringUtils :: format ( \"Particle num:%d\" , nParticle )); } for ( auto body : getScene () -> getPhysicsWorld () -> getAllBodies ()) { if ( body -> getNode () -> getPosition (). y < 0 ) { nodevector . eraseObject ( body -> getNode ()); body -> getNode () -> removeFromParentAndCleanup ( true ); nParticle -- ; nParticleLabel -> setString ( StringUtils :: format ( \"Particle num:%d\" , nParticle )); } } rt -> beginWithClear ( 0 , 0 , 0 , 0 ); for ( auto node : nodevector ) { auto sp = Sprite :: create ( \"blurball.png\" ); sp -> setPosition ( node -> getPosition ()); sp -> visit (); } rt -> end (); rtsp -> setTexture ( rt -> getSprite () -> getTexture ()); rtsp -> setFlippedY ( true ); } 在每一帧中将模糊过的小球渲染在RenderTexture上，小球的位置对应物理节点的位置。然后取出整个RenderTexture中的材质，替换 rtsp 的材质。最终渲染在屏幕上的只有一个Sprite，通过不断改变它的材质达到动画效果。 好了，最终效果： 基本达到了示例博客中的效果，因为显示的其实是一个Sprite，所以可以添加背景图和桶壁等，设置好Zorder即可。 本篇中讲解了最基本的流体模拟处理方法，从结果来看与水流还有很大差距，只能模拟比较粘稠的类似于泥浆的流体。那么从下一篇开始将逐步改进，使其更加逼真。 在中级篇中，将尝试整合Google出品的开源项目 liquidfun ，以求达到更好的效果。 在高级篇中，将探讨流体模拟相关算法SPH( Smoothed Particle Hydrodynamics )，弄明白其原理，尝试代码实现。 这里 有一篇很好的参考博客。 当然，前提是我有时间的话...这些工程量有点大。","tags":"Cocos2d-x","title":"Cocos2d-x实现流体模拟（初级篇）"},{"url":"http://blog.game18.net/posts/2015/11/ying-yong-zi-ding-yi-shadershi-xian-gao-si-mo-hu/","text":"是时候研究真正的技术了！深入Cocos2d-x引擎核心，利用Shader实现更炫酷的效果。 掌握了Cocos2d-x的基本应用之后，是不是已经不能满足于基本的精灵和动画效果了？本篇就向游戏引擎的核心迈进一步，利用自定义Shader实现高斯模糊效果。参考文章： RenderTexture + Blur 中文翻译 高斯模糊 模糊算是一种比较常见的特效，窗口半透明的效果就是通过模糊实现的，可以表现出较好的质感。模糊算法有很多种，举个简单的例子：把某个像素的值设为它和周围相邻的8个像素的平均，处理后图像的很多细节被抹去，看起来就变得模糊，这种方式叫均值模糊（Box Blur）。 显然，均值模糊是所有点的权重都为1的模糊，这种处理方式比较简单粗暴。考虑到实际情况，可以给像素赋予一定的权重，比如像素点自身的颜色赋予较大权重，使其更多地影响模糊结果，而周围像素的权重随距离增大而减小。 高斯模糊（Gaussian Blur）即是这样一种模糊方式，它采用高斯函数计算每个点的权重，所有的权重值符合正态分布规律。在2维平面中的高斯函数如下（又用到LaTeX了，效果真不错）： $$G(x,y)=\\frac{1}{2\\pi\\sigma&#94;2}e&#94;{-\\frac{x&#94;2+y&#94;2}{2\\sigma&#94;2}}=\\frac{1}{\\sqrt{2\\pi}\\sigma}e&#94;{-\\frac{x&#94;2}{2\\sigma&#94;2}}\\times\\frac{1}{\\sqrt{2\\pi}\\sigma}e&#94;{-\\frac{y&#94;2}{2\\sigma&#94;2}}=G(x)G(y)$$ 函数图像： 高斯函数有几个特性： 中心点的值最大，两侧对称 函数值总和为1，离中心点3 \\(\\sigma\\) 距离外函数值接近于0,可忽略。因此可认为函数值集中在（-3 \\(\\sigma\\) ，3 \\(\\sigma\\) ）区间内 一个n \\(\\times\\) n阶的高斯模糊可以分解为水平垂直两次n阶模糊的叠加 然后我们来计算各点权重，这种小事当然是直接打开ipython-notebook喽： import math class Gaussian : def __init__ ( self ): self . pointnum = 7 self . sigma = 3.0 self . weights = [ 1.0 ] * ( self . pointnum + 1 ) self . para1 = 1.0 / ( math . sqrt ( 2 * math . pi ) * self . sigma ) self . para2 =- 1.0 / ( 2.0 * self . sigma ** 2 ) def calculateweights ( self ): for i in range ( 1 , self . pointnum + 1 ): self . weights [ i ] = self . para1 * math . exp ( self . para2 * float ( i ) ** 2 ) self . weights [ 0 ] -= 2.0 * self . weights [ i ] def printweights ( self ): for i in range ( - self . pointnum , self . pointnum + 1 ): print u\"point %d : %f \" % ( i , self . weights [ abs ( i )]) test = Gaussian () test . calculateweights () test . printweights () 得到的值如下： point -8 : 0.003799 point -7 : 0.008741 point -6 : 0.017997 point -5 : 0.033159 point -4 : 0.054670 point -3 : 0.080657 point -2 : 0.106483 point -1 : 0.125794 point 0 : 0.137401 point 1 : 0.125794 point 2 : 0.106483 point 3 : 0.080657 point 4 : 0.054670 point 5 : 0.033159 point 6 : 0.017997 point 7 : 0.008741 point 8 : 0.003799 这种算法实际上把距离更远而没有计算的点的权重都累加在中心点上，保证总和为1，不会因为模糊处理而损失颜色和透明度。 着色器 Cocos2d-x基于OpenGLES2.0，有关OpenGL的相关概念，这里就不做太深入的研究了。我之前购买一本\u0007OpenGL蓝宝书，啃起来很费劲，OpenGL本来就晦涩难懂，又加需要很多数学计算，看着头痛。不过没关系，只要浅显的知识就足以解决今天的问题。 在渲染中使用到的着色器（shader）一般有两种：顶点着色器（Vertex Shader ）和片段着色器（Fragment Shader）。其中顶点着色器主要处理顶点数据，计算变换、光照等效果；片段着色器则处理最终渲染的颜色材质等。利用显卡的并行处理优势着色器代码会对图像的每个像素执行计算，所以考虑执行效率的话尽量不要包含复杂的语句。 模糊变换对顶点不做改变，所以我们只需要自定义片段着色器即可。着色器采用着色器语言编写，语言风格和C基本相同。先上代码： #ifdef GL_ES precision mediump float ; #endif varying vec4 v_fragmentColor ; varying vec2 v_texCoord ; //uniform sampler2D CC_Texture0; uniform vec2 resolution ; uniform vec2 direction ; uniform float radius ; void main () { vec4 sum = vec4 ( 0.0 ); float pixelsizex = radius / resolution . x ; float pixelsizey = radius / resolution . y ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x - 7.0 * pixelsizex * direction . x , v_texCoord . y - 8.0 * pixelsizey * direction . y )) * 0.003799 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x - 7.0 * pixelsizex * direction . x , v_texCoord . y - 7.0 * pixelsizey * direction . y )) * 0.008741 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x - 6.0 * pixelsizex * direction . x , v_texCoord . y - 6.0 * pixelsizey * direction . y )) * 0.017997 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x - 5.0 * pixelsizex * direction . x , v_texCoord . y - 5.0 * pixelsizey * direction . y )) * 0.033159 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x - 4.0 * pixelsizex * direction . x , v_texCoord . y - 4.0 * pixelsizey * direction . y )) * 0.054670 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x - 3.0 * pixelsizex * direction . x , v_texCoord . y - 3.0 * pixelsizey * direction . y )) * 0.080657 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x - 2.0 * pixelsizex * direction . x , v_texCoord . y - 2.0 * pixelsizey * direction . y )) * 0.106483 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x - 1.0 * pixelsizex * direction . x , v_texCoord . y - 1.0 * pixelsizey * direction . y )) * 0.125794 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x , v_texCoord . y )) * 0.137401 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x + 1.0 * pixelsizex * direction . x , v_texCoord . y + 1.0 * pixelsizey * direction . y )) * 0.125794 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x + 2.0 * pixelsizex * direction . x , v_texCoord . y + 2.0 * pixelsizey * direction . y )) * 0.106483 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x + 3.0 * pixelsizex * direction . x , v_texCoord . y + 3.0 * pixelsizey * direction . y )) * 0.080657 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x + 4.0 * pixelsizey * direction . x , v_texCoord . y + 4.0 * pixelsizey * direction . y )) * 0.054670 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x + 5.0 * pixelsizex * direction . x , v_texCoord . y + 5.0 * pixelsizey * direction . y )) * 0.033159 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x + 6.0 * pixelsizex * direction . x , v_texCoord . y + 6.0 * pixelsizey * direction . y )) * 0.017997 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x + 7.0 * pixelsizex * direction . x , v_texCoord . y + 7.0 * pixelsizey * direction . y )) * 0.008741 ; sum += texture2D ( CC_Texture0 , vec2 ( v_texCoord . x - 8.0 * pixelsizex * direction . x , v_texCoord . y - 8.0 * pixelsizey * direction . y )) * 0.003799 ; gl_FragColor = v_fragmentColor * sum ; } 简单讲解一下： varying声明的两个变量是从顶点着色器传过来的，v_texCoord是坐标，v_fragmentColor是对应的颜色值。 uniform声明的变量是运行时可以从外部传入的，这里我们需要传入图片的大小resolution，采样间隔radius，以及模糊方向direction。 在OpenGL中没有像素的概念，整个图像的尺寸归一化为单位长度，所以1/resolution即是一个像素的大小。采样方向可以传入水平或垂直的单位向量，兼容两种模糊模式。 下面的main函数很好理解，将每个采样点的颜色乘以相应权重然后相加，最终输出的gl_FragColor即是要渲染在屏幕上的颜色值 CC_Texture0是Cocos2d-x中默认传入的材质uniform，其实就是要做模糊处理的图片。网上很多教程中有显式的声明，但我在Cocos2d-x3.8中测试显式声明会报错，需要注意。 Cocos2d-x中对着色器进行了封装，而且在不同版本中差异较大，导致使用时代码上会有一些不同。 着色器代码也需要经过编译和连接才能使用，但在Xcode环境中不会反馈任何编译错误。所以一定要仔细检查语法，出错的话很难定位。（例如浮点数赋值的时候千万别在后面加f，我检查了n遍才发现...） Cocos2d-x中应用自定义Shader 接下来就把自定义的shader整合到代码中，实现一个应用自定义shader的Sprite类。只要实现下列几个函数就行： #ifndef ShaderSprite_hpp #define ShaderSprite_hpp #include <stdio.h> #include \"cocos2d.h\" USING_NS_CC ; class ShaderSprite : public Sprite { public : ShaderSprite (); virtual ~ ShaderSprite (); static ShaderSprite * create ( const std :: string filename , Vec2 direction , float radius ); static ShaderSprite * createWithTexture ( Texture2D * texture , const Rect & rect , Vec2 direction , float radius ); bool initWithFile ( const std :: string & filename , Vec2 direction , float radius ); bool initWithTexture ( Texture2D * pTexture , const Rect & tRect , Vec2 direction , float radius ); GLProgram * getCustomGLProgram ( Vec2 resolution , Vec2 direction , float radius ); }; #endif /* ShaderSprite_hpp */ 几个构造函数完全照着CCSprite源码写即可，主要是把shader所需的3个参数传入。重点说两个函数: bool ShaderSprite :: initWithTexture ( cocos2d :: Texture2D * pTexture , const cocos2d :: Rect & tRect , Vec2 direction , float radius ){ do { CC_BREAK_IF ( ! Sprite :: initWithTexture ( pTexture , tRect , false )); auto _program = getCustomGLProgram ( tRect . size , direction , radius ); setGLProgram ( _program ); return true ; } while ( 0 ); return false ; } 所有构造函数都调用上面这个 initWithTexture ,在其中应用了自定义的GLProgram。而 getCustomGLProgram 代码如下： GLProgram * ShaderSprite :: getCustomGLProgram ( Vec2 resolution , Vec2 direction , float radius ){ //获取着色器代码字符串 auto filepath = FileUtils :: getInstance () -> fullPathForFilename ( \"Gaussian_Blur.fsh\" ); auto fshstring = FileUtils :: getInstance () -> getStringFromFile ( filepath ); //创建GLProgram auto _program = GLProgram :: createWithByteArrays ( ccPositionTextureColor_noMVP_vert , fshstring . c_str ()); if ( _program ) { //创建GLProgramState auto _programstate = GLProgramState :: getOrCreateWithGLProgram ( _program ); setGLProgramState ( _programstate ); //传入参数 _programstate -> setUniformVec2 ( \"resolution\" , resolution ); getGLProgramState () -> setUniformVec2 ( \"direction\" , direction ); getGLProgramState () -> setUniformFloat ( \"radius\" , radius ); CHECK_GL_ERROR_DEBUG (); return _program ; } return nullptr ; } Cocos2d-x版本更新过程中不断加强对GLProogram和GLProgramState的封装，应该是希望让用户能更简单地进行操作，尽量不用接触底层OpenGL的东西。上面的代码中可以看出，Cocos2d-x将shader封装到GLProgram中，完成着色器的编译、连接等工作；而uniform等参数被封装到GLProgramState中，一些初始化和传参工作都利用GLProgramState完成。网上一些旧版本的示例代码中还保留诸如 bindAttribLocation 、 updateuniforms 等操作在当前版本中已经不再需要了。 但这种做法有利有弊，它也损失了很多OpenGL的自由度。参考博文中采用在外部计算权重，然后使用1维浮点数组传入Shader。我最初也想使用同样的方式，但我发现GLProgramState并未提供传递1维浮点数组的函数。尝试使用 setUniformLocationWith1fv 传递数组也不起作用，好像应用GLProgramState后就无法接受其他的参数。跟踪了一下源码，以后有机会再仔细展开写写。 实现效果 下面就利用ShaderSprite实现高斯模糊效果，最后还有一个问题需要解决。按照第一节所说，我们要将n \\(\\times\\) n阶模糊计算分解为水平竖直两次n阶模糊处理，于是需要存放中间的处理结果。还记得 这篇博文 中涉及到的RenderTexture吗？正好拿来作为\"中转站\"。好了，上代码： auto radius = 2 ; auto size = Director :: getInstance () -> getWinSize (); auto sporigin = Sprite :: create ( \"grossini.png\" ); auto spblurhorizontal = ShaderSprite :: create ( \"grossini.png\" , Vec2 ( 1 , 0 ), radius ); auto spblurvertical = ShaderSprite :: create ( \"grossini.png\" , Vec2 ( 0 , 1 ), radius ); auto spblurtemp = ShaderSprite :: create ( \"grossini.png\" , Vec2 ( 1 , 0 ), radius ); spblurtemp -> setPosition ( Vec2 ( sporigin -> getContentSize (). width / 2 , sporigin -> getContentSize (). height / 2 )); auto rt = RenderTexture :: create ( sporigin -> getContentSize (). width , sporigin -> getContentSize (). height ); rt -> begin (); spblurtemp -> visit (); //将水平模糊的图像渲染在RenderTexture中 rt -> end (); auto spblur = ShaderSprite :: createWithTexture ( rt -> getSprite () -> getTexture (), Rect ( 0 , 0 , sporigin -> getContentSize (). width , sporigin -> getContentSize (). height ), Vec2 ( 0 , 1 ), radius ); //取出RenderTexture中的材质，垂直模糊后渲染在屏幕上 spblur -> setFlippedY ( true ); //不要忘记RenderTexture中的材质是上下颠倒的 sporigin -> setPosition ( Vec2 ( size . width / 4 , size . height * 3 / 4 )); spblurhorizontal -> setPosition ( Vec2 ( size . width * 3 / 4 , size . height * 3 / 4 )); spblurvertical -> setPosition ( Vec2 ( size . width / 4 , size . height / 4 )); spblur -> setPosition ( Vec2 ( size . width * 3 / 4 , size . height / 4 )); addChild ( sporigin ); addChild ( spblurhorizontal ); addChild ( spblurvertical ); addChild ( spblur ); 看看效果： 大功告成！但是多阶高斯模糊和RenderTexture都非常消耗系统资源，使用时一定要注意，非必要时尽量选择其他替代方案。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"Cocos2d-x","title":"应用自定义Shader实现高斯模糊"},{"url":"http://blog.game18.net/posts/2015/10/root-firehdx7-zhi-hou-de-yi-xie-wen-ti/","text":"继上一篇Root了Kindle FireHDX 7之后,昨天又研究了一晚,成功运行第三方ROM,生命在于折腾! 昨天搞定FireHDX的Root之后还是遇到了问题,google play使用几次后就白屏无法载入.试着按照上一篇中参考博客的方法重装了google play,结果更糟糕,重启后显示Google的欢迎界面无法跳过,点下一步就断网,配置好网络再点又断网.如果不跳过欢迎界面会导致底部的navigation bar无法显示,随之而来的就是无法后退,无法回桌面等一系列问题.系统算是被我彻底搞坏了,只好重新来过,这次直接上Safestrap+CyanogenMod,一劳永逸搞定ROM问题. 声明: 本教程只适用于FireHDX7设备.刷机有风险,操作需谨慎,对于由此造成的变砖,损坏等问题,本人概不负责. 如果你的FireHDX还没有Root,请参考我的上一篇 Kindle FireHDX7 ROOT 方法 ,确保设备已经Root,先不要安装GApps.(尽量保持系统清洁,之后这个系统只作为备份恢复用,越小越省空间.) 在 这里 下载 Safestrap for THOR ,直接下载链接点 这里 ,直接安装apk即可.Safestrap可以将设备当前的ROM备份存储,并提供多个ROM-Slot供用户安装其他Rom,之后可以在各个Rom之间灵活切换.一旦Slot中安装的Rom出问题还可以切回备份的默认Rom,灵活性和安全性兼备.安装Safestrap之后设备启动时会有一个选择界面,可选择进入Recovery或者System. 打开Safestrap,点击 Install Recovery ,安装完成后左上角 State 变为 Installed .点击 Reboot to Recovery ,系统重启并进入Recovery界面,如下图:(在Recovery中截图不便,之后我就只写按钮名称) 从界面顶部可以看到 ROM Slot:stock 表明当前使用的是默认Rom,点击 Backup ,勾选 Data 和 System 两项,滑动最下方的滑块,即可备份默认Rom,这样以后折腾出了问题就不怕了.先回到主菜单,点击 Reboot 重启至 System . 下面准备新Rom(资源都在国外网站,下载速度可能比较慢, 我之后会传一份到 百度云链接见 本文最后 ),在 这里 下载 Thor ROM .在 这里 下载 GApps ,下载时前两项选择 ARM,4.4 最后一项是包含组件的多少,推荐选择 mini 或者参考网页中的介绍选择(这个资源无论在墙里还是墙外都很慢,下不动的可以去 gapps吧 查找对应版本,有人提供了百度云的链接.在 这里 下载 SuperSU (选择 CWM / TWRP / MobileODIN installable ZIP 版本). 回到设备上操作,把上述下载的3个zip文件(Rom,Gapps,SuperSU)拷贝至设备存储中,比如放在 Download 文件夹下.重启系统进入 Recovery ,点击 Boot Options 点击 Rom-Slot-1 ,设置 Data partition size 我想让这个新系统使用所有的剩余空间,我就把它设置到比下方的 Free Space 稍小. 这里我起初的理解有误,在下一步详细解释.然后点击 Create ROM Slot 等待分区建好. Data partition size 实际上设置的是系统中用来装app的空间,即根目录下的 Data 文件夹,可以视需要装app的大小而定,确定之后会固定占用存储中的空间,设定太大的话会浪费,设定太小的话安装app时会报空间不足.下图中我使用了默认的2.5G,以及系统选项-存储中可用空间显示. 建好分区后点击 Activate 启用这个Slot,此时顶部应该显示 ROM Slot:rom-slot1 .回到主菜单,点击 Install 找到 Download 文件夹,点选Rom的zip文件,在新的界面中点击 Add More Zips 把其它2个文件都选中,滑动下方的滑块开始安装.(我在安装时是分开单独安装3个zip,一起安装应该也没问题) 安装完成后重启设备至 System ,一个具备Root和GApps的全新系统就做好了,至此可以跟FireHDX原生系统Say Bye Bye! 所有资源下载链接点 这里 密码:9tef","tags":"随笔","title":"ROOT FireHDX7 之后的一些问题"},{"url":"http://blog.game18.net/posts/2015/10/kindle-firehdx7-root-fang-fa/","text":"手头有一台FireHDX7,是神奈同学送的礼物.要说这台机器真是价廉物美,不仅性能不错,尺寸也很合适日常使用.但是Amazon家的设备有个坏毛病:系统封闭,没法装google play,让人很不爽。早在FireOS3的时候我使用某个一键root工具搞定过，后来想尝鲜FireOS4就升了个级,之后就再没有能root的消息.没有googleplay也导致了我的COC一度没法同步村庄,停滞了好久.昨天突然在XDA看到一个方法,尝试一下成功root,在这把流程记录一下. 声明: 本教程只适用于FireHDX7设备,8.9设备请参考 原帖 .root有风险,操作需谨慎,对于由此造成的变砖,损坏等问题,本人概不负责.root操作会抹掉设备内所有数据,请提前做好备份. Root方法来自XDA论坛,帖子在 这里 经在我的机器上实测可行,现在就把步骤稍微翻译一下,方便大家参考. 确认当前系统版本为4.5.5或以下,我的机器正好是4.5.5 如果系统版本高于3.2.8先降级至3.2.8.下载3.2.8版本固件: 百度网盘 密码:joi6 将下好的文件放在设备的 storage 目录下,进入 设置-设备选项-系统更新 可以看到有更新系统的提示(如无提示升级可先关掉wifi再看),点击升级 (会抹去设备内数据,请提前备份) .系统更新完成后重启,查看系统版本是否已降至3.2.8. 由于root程序只适用于4.5.2版本,现在需要把设备升级至4.5.2,固件版本列表在 这里 ,直接下载FireHDX7 注意是7 的4.5.2版固件点 这里 .依然是放在 storage 目录-点击升级-重启,查看系统版本是否为4.5.2.如果现在wifi还开着的话先关掉,以防系统自动下载升级包. 到 这里 下载root程序,直接下载点 这里 .安装下载的apk,运行,界面上就一个按钮,点击,过一会系统自动重启(论坛某个地方说最好再手动重启一次,那就再重启一次以防万一).看看亲切的 SuperSU 图标是不是已经出现了? 接下来还不能掉以轻心,因为只要你联网系统就会自动更新系统,之前就白干了.先安装一个文件浏览器比如 Root Explorer ,在 /system/priv-app/ 目录下查找 DeviceSoftwareOTA.apk ,然后将它改成任意其他名字, 注意:扩展名一定不能是apk,直接删除扩展名也可 .这样就杜绝了自动升级的问题,可以放心连wifi了. 到这里我们就彻底拿回了Root权限,当下一步就是把GooglePlay请回来.原帖中最后一个链接除了讲禁用自动升级还讲了安装GApps的步骤,但我感觉有点复杂,我参考了 这里 的方法,步骤如下: ( 这种方法经测试有问题,请参考 这篇博客 ) 下载 Xposed Framework 和 HDXPosed.apk 并安装 打开 Xposed ,点击第一栏,安装框架,点击模块栏,启动 HDXPosed 模块 重启 在 这里 下载GApps,逐个安装 Login GooglePlay And Enjoy !","tags":"随笔","title":"Kindle FireHDX7 ROOT 方法"},{"url":"http://blog.game18.net/posts/2015/10/mo-ta-you-xi-shi-xian-si-lu/","text":"发现一款游戏叫《魔塔》，是一个8bit风格的RPG游戏，主人公出生在一个多层迷宫里，各层迷宫之间通过楼梯相连，每层迷宫中有怪物，门，钥匙，血瓶等，不同颜色的门需要对应颜色的钥匙开启，遇到怪物会开启战斗，最终目标是消灭某一层的boss。 从功能点上来看与之前实现的RPG游戏Demo重合度很高。先分析记录一下实现思路,如果以后有时间和兴趣的话考虑自己做一下. 需要重新构架游戏实现机制，肯定不能逐层写代码实现，而应该完成一种读入游戏资源即可进行游戏的框架，之后只要策划将游戏资源导入即可. 目前想到需要实现的东西： 数据信息存放在sqlite中，从读入的ID获得相应数据 地图分层，从tiledmap读入以下信息： 障碍层（墙，火盆，植物等无法穿越）读入后可用来寻路 敌人层，可读入敌人ID npc层，读入npc ID， 物品层，读入物品ID 门，读入门的颜色 传送门，读入传送门ID用来判断传送至哪一层（游戏原型中只有上一层和下一层两种传送门） 点击目标点后寻路，使用A*寻路，如寻路不成功不移动。寻路成功的话开始移动，移动中如果下一格有敌人，门等采取以下策略 遇到敌人：开启对话框，显示敌人一句对话，有是否战斗的按钮 遇到门：检查背包中是否有对应颜色的钥匙，开启提示框，是否使用钥匙开门（原型中有手持宝剑可破坏一部分门，使用炸弹可破坏栅栏，但炸弹有消耗，与钥匙相同。宝剑的耐久可以设置为-1，永久有效） 寻路算法中可以考虑给怪赋一个较高的移动消耗值与lv相关，使得主角最优先选择无障碍道路，被多怪拦住后会选择级别较低的怪突破 游戏原型中战斗界面采取需要玩家干预，根据玩家点击的时机产生miss hit critical的不同攻击，此方式比起自动战斗游戏性更好，且容易实现，不同怪物也能区分难度，值得借鉴，可以学着做一个别的形式. 宝箱，npc，以及其他收集道具的处理以及npc触发任务的处理有待细化.","tags":"Cocos2d-x","title":"魔塔游戏实现思路"},{"url":"http://blog.game18.net/posts/2015/10/cocos2d-xfang-da-jing-xiao-guo/","text":"挖一篇以前写的笔记,如何用Cocos2d-x实现放大镜效果.主要思路是使用图片的一部分创建Sprite,然后setscale,将生成的sprite添加到点击位置.如果原图分辨率不够的话也可以使用另外的大图,截取范围按照两张图的分辨率比值设定.如果对ontouchmoved进行响应,改变截取的位置,生成新的texture,然后使用sprite->settexture即可实现拖动效果.在ontouchended中销毁sprite即可.基本功能实现非常简单,效果如下: 实现起来虽然简单,但是方形的放大框非常不自然.下面我们就在Cocos2d-x中实现圆形外框的放大镜效果.先看代码: Sprite * HelloWorld :: getMaskedSprite ( cocos2d :: Rect rect ){ Sprite * textureSprite = Sprite :: create ( \"bg.png\" , rect ); Sprite * maskSprite = Sprite :: create ( \"mask.png\" ); //创建RenderTexture,尺寸符合mask RenderTexture * rt = RenderTexture :: create ( maskSprite -> getContentSize (). width , maskSprite -> getContentSize (). height ); maskSprite -> setPosition ( maskSprite -> getContentSize (). width / 2 , maskSprite -> getContentSize (). height / 2 ); textureSprite -> setPosition ( textureSprite -> getContentSize (). width / 2 , textureSprite -> getContentSize (). height / 2 ); //对于mask,需要先渲染到RenderTexture上,源因子1,目标因子0 maskSprite -> setBlendFunc ( BlendFunc { GL_ONE , GL_ZERO } ); //对于原图,渲染的时候透明度采用mask的透明度,这样在mask透明的地方原图也透明,实现蒙板效果,目标因子0去掉mask textureSprite -> setBlendFunc ( BlendFunc { GL_DST_ALPHA , GL_ZERO } ); //开始渲染,先是mask,然后原图 rt -> begin (); maskSprite -> visit (); textureSprite -> visit (); rt -> end (); //提取sprite Sprite * final = Sprite :: createWithTexture ( rt -> getSprite () -> getTexture ()); //反转Y轴,纹理创建时Y轴是反的 final -> setFlippedY ( true ); return final ; } mask是一个圆形图片,长这样: 当然,也可以用其他形状的图片生成各种各样的蒙版. RenderTexture ,可以把它想象为一块可以渲染的画布,它不在屏幕显示的范围内.就像一块调色板,我们可以先用颜料在调色板上调出颜色,再去画板上画画. BlendFunc 是颜色混合函数,用于将源图像和目标图像混合在一起,它提供了多种混合方式,详细说明如下: BlendFunc{GL_ONE,GL_ZERO}这一句设定了一个颜色混合的公式:源因子是1,目标因子是0,于是maskSprite原样复制到画布上,而画布上不管之前有什么颜色,都乘以0,屏蔽掉了. BlendFunc{GL_DST_ALPHA,GL_ZERO}这是另一个公式:源因子是使用目标的透明度,目标因子是0,于是textureSprite的透明度先被设置成maskSprite的透明度,maskSprite是一个圆形,周围是透明的,于是textureSprite除中间圆形区域以外的其他区域被透明化,而目标因子是0,屏蔽掉了maskSprite,最后就只显示了textureSprite的中间部分,其实还是个方形区域,但是周围变透明了. 有一个需要注意的地方,如果Sprite使用了create方法(无论是哪种Create)内部都是会retain一次,但是像rt->getSprite()这种就不是,于是这样取回的Sprite会很快被销毁掉,所以采用使用texture再重建一次然后再返回. 效果如下: 代码见 这里 . 其实稍作改动,我们还可以实现更有趣的效果.比如: 怎么样, 无论从哪个方面来看 效果很不错吧? 是不是有些小激动呢?（¯﹃¯）嘿嘿嘿嘿....","tags":"Cocos2d-x","title":"Cocos2d-x放大镜效果"},{"url":"http://blog.game18.net/posts/2015/10/pythonzhua-qu-wang-ye-shu-ju/","text":"稍微花了点时间学习Python,真是一种好用的语言啊.相对于要求严格的C++,Python非常自由、简单、方便.有时候让我有一种\"这么随便会不会出什么问题?\"的感觉.基本上稍微看一下文档我就能上手干活了,做了一个抓取网页数据的小工具.感谢 静觅的博客 详细讲解了Python爬虫,更棒的是有多个实例供参考. 因为上面推荐的博客里讲解已经非常细致,我就直接上代码好了.另外关于html的基本概念可以参考 这里 . 我们今天要爬的网站是这个: 駿河屋 ,一个日本的电商网站,我们希望能把商品信息抓出来供以后使用.IDE方面,我使用的是Anaconda家的Pycharm,另外还附带一个网页版的界面叫IPython Notebook(Jupyter),可以随写随运行,写比较小的脚本时很方便.那么好,上代码: import urllib import urllib2 import re from bs4 import BeautifulSoup class CRAWSURUGA : def __init__ ( self ): self . user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)' self . headers = { 'User-Agent' : self . user_agent } #商品类别 self . category = '' #名称关键字 self . searchWord = '' #页码 self . pageIndex = 1 #判断是不是最后一页 self . isLastPage = True #最大读取页数 self . maxPageIndex = 5 def getPage ( self ): try : #请求的各项参数 values = {} #物品种类 values [ 'category' ] = self . category #关键字 values [ 'search_word' ] = self . searchWord #页码 values [ 'page' ] = self . pageIndex #不读取图片 values [ 'photo' ] = 'Off' data = urllib . urlencode ( values ) #组合查询url url = 'http://www.suruga-ya.jp/search?' + data #构建请求的request request = urllib2 . Request ( url , headers = self . headers ) #利用urlopen获取页面代码 response = urllib2 . urlopen ( request ) #读取页面内容 pageCode = response . read () #异常处理 except urllib2 . URLError , e : if hasattr ( e , \"reason\" ): print u\"连接失败,错误原因\" , e . reason return None print '已读取第 %d 页' % self . pageIndex #使用BeautifulSoup解析页面 soup = BeautifulSoup ( pageCode , \"lxml\" ) #如果找到有next的链接,说明不是最后一页,否则是最后一页 if soup . find ( \"link\" , rel = \"next\" ): self . isLastPage = False else : print 'last page' self . isLastPage = True return pageCode #取得查询的物品件数 def getItemNum ( self ): #读取网页 pagecode = self . getPage ( self . pageindex ) if not pagecode : print '页面加载失败' return None #利用正则匹配查找'該当件数' pattern = re . compile ( r'該当件数:([\\d,]+?)&' , re . S ) items = re . findall ( pattern , pagecode ) if not items : print '获取物件数失败' return None #去掉数据中的',' itemnum = int ( items [ 0 ] . replace ( ',' , '' )) print itemnum return itemnum #获取页面中的所有商品 def getItems ( self ): #读取页面 pagecode = self . getPage () if not pagecode : print '页面加载失败' return None #使用BeautifulSoup解析页面 soup = BeautifulSoup ( pagecode , \"lxml\" ) #查找页面中所有table标记,每个table标记中存放一个商品 tables = soup . find_all ( 'table' ) for table in tables : if table . has_attr ( 'class' ): #读取商品状态:新品/中古/预约... print table . tr . span . img [ 'alt' ] #读取商品类别 print table . tr . span . contents [ 2 ] . replace ( '[' , '' ) #读取发售日 print table . tr . td . next_sibling . string #读取商品名称 print table . tr . next_sibling . next_sibling . b . string #读取发售公司 pattern = re . compile ( r'\\[.*?\\]' ) match = re . search ( pattern , table . tr . next_sibling . next_sibling . next_sibling . next_sibling . td . string ) if match : print match . group () #读取商品价格 stringprice = '' for string in table . tr . next_sibling . next_sibling . next_sibling . next_sibling . td . next_sibling . next_sibling . strings : stringprice += string #打印完整价格,定价,税后 pattern = re . compile ( u' \\uffe5 ([\\d,]*)' , re . S ) items = re . findall ( pattern , stringprice ) if items : for item in items : #去掉价格中的',' item = item . replace ( ',' , '' ) print item print '==============================' #输入查询条件 def inputFilter ( self ): print '输入商品类别(留空为全商品): \\n ゲーム:2 \\n 映像ソフト:3 \\n 音楽ソフト:4 \\n おもちゃ・ホビー:5 \\n PCソフト:6 \\n 本:7 \\n 電気製品:8 \\n 食品・食玩:9 \\n 雑貨・小物:10 \\n 同人:11' self . category = raw_input () print '输入搜索关键字:' self . searchWord = raw_input () print '输入初始页码(默认为1):' page = raw_input () if page != '' : self . pageIndex = int ( page ) print '输入最大读取页数(默认为5):' maxpage = raw_input () if maxpage != '' : self . maxPageIndex = int ( maxpage ) 整个过程大体上分两步,第一步是读取网页内容,第二步是查找数据.在查找数据的时候使用了两种方法,第一种是正则表达式匹配,第二种是使用BeautifulSoup解析网页. 正则表达式匹配方式很好理解,语法方面要记得东西比较多(参考 这里 ).注意两点: 括号的使用,在正则表达式模板中每个括号代表一个分组,可以从适配模板的文本中\"抠出\"需要的信息,如上面代码中获取物品件数时使用的正则表达式: '該当件数:([\\d,]+?)&' 问号的使用,正则表达式默认是贪婪匹配的,就是会尽可能多的匹配字符.一般我们会使用问号将其改为非贪婪模式.例如比较常见的使用 .*? 来匹配任意字符, .*?a 表示匹配到遇到的第一个字符 a 为止,不加问号的话会一直匹配下去. BeautifulSoup可将页面解析后按照层级结构组成一个对象,访问时可以使用网页标签查找相应的内容,当然也支持正则搜索.另外,BeautifulSoup还提供了对父节点,子节点,兄弟节点等的访问方法,可以较灵活地按照网页结构获取所需内容.在上面代码中查找发售公司和商品价格时都用了兄弟节点的访问方法.对于网页中某些缺乏关键字而难以使用正则匹配的数据,BeautifulSoup的这种结构化访问方式非常好用. 所有功能都写完了,最后把它们调用起来: test = CRAWSURUGA () test . inputFilter () while True : test . getItems () if test . isLastPage : print 'read to last page,stop' break elif test . pageIndex == test . maxPageIndex : print 'read to max pageindex,stop' break else : test . pageIndex += 1 运行一下,输入查询条件: 输入商品类别(留空为全商品): ゲーム:2 映像ソフト:3 音楽ソフト:4 おもちゃ・ホビー:5 PCソフト:6 本:7 電気製品:8 食品・食玩:9 雑貨・小物:10 同人:11 7 输入搜索关键字: ONEPIECE 输入初始页码(默认为1): 输入最大读取页数(默认为5): 输出结果: 已读取第1页 中古 アニメムック [発売日 2014/03/09] ONEPIECE STRONGWORDS 2 [集英社] 821 200 ============================== 中古 アニメムック [発売日 2011/04/20] ONEPIECE STRONGWOR 下 [集英社] 798 200 ============================== 中古 アニメムック . . . 已读取第2页 . . . 已读取第5页 . . . read to max pageindex,stop 中间数据太多就省略掉了,可以看到我们的目标已经达到.因为只是一个简单的测试,仅做了打印输出. 总结: Python爬网页数据真方便!","tags":"Python","title":"Python抓取网页数据"},{"url":"http://blog.game18.net/posts/2015/10/geng-huan-bo-ke-zhu-ti/","text":"刚弄好的博客突然间挂掉了.运行 make html 的时候所有md文件都报 OSError: [Errno 2] No such file or directory. 分明之前还好好的.分析了一下traceback,发现问题出在 extract_toc 插件.在elegant主题作者的 博客 上可以看到左边有一个 Contents 栏,可以在页面中定位文章的条目,从而方便地在内容之间跳转,很好的一个功能.作者的博客中说要使用这个功能的话需要引入 extract_toc 插件. 顺便说一句需要看Pelican的log,使用 pelican -D -s pelicanconf.py content -o output 而不是make html来运行Pelican 在插件列表中添加 extract_toc 后就出现上面的错误,即使把其他插件都删除只剩 extract_toc 还是会报错.看了一下 extract_toc 的 代码 ,发现这么一段: try : from pandoc_reader import PandocReader except ImportError : PandocReader = False 看来这个插件还擅自引用了 pandoc_reader 这个插件.查看其 代码 : proc = subprocess . Popen ( pandoc_cmd , stdin = subprocess . PIPE , stdout = subprocess . PIPE ) 这里运行时报错,在stackoverflow上有很多类似的问题,subprocess.Popen经常会引起 raise child_exception 然后 No such file or directory. 从他们的讨论内容看来似乎是PATH方面的问题. 如果在 extract_toc 中忽略对 pandoc_reader 的检查直接返回False的话是可以避免报错,但是返回给Pelican的toc仍然是None,在Pelican代码中有个检测,toc为None的时候Content不显示,所以添加 extract_toc 也就没有意义了. 我顺着报错的地方看了一些源码,但还是搞不明白原因.elegant这种用户很多的theme按说出了bug应该会有很多人反映,而且据说elegant的作者更新也很勤快.所以我感觉应该是我的配置或者环境有些问题.在 这里 博主也有提到: plugin的执行顺序是随机的（坑爹），所以最好不要有相互依赖的关系 之后有时间继续研究一下这个问题吧.当务之急是让把博客恢复起来.我把官方Git上的所有主题截图都浏览过,喜欢的并不多,有几个虽然看起来很漂亮,但又有点过于文艺范.后来我发现很多博客都在用 pelican-bootstrap3 主题,风格比较简约适合技术博客. 按着readme配置了一下,发现这个主题可配置的地方很多,功能比较完善.我最喜欢的是可定制的顶部banner,用了黑猫的图片加上黑白配色,堪称完美. 于是Bolg满血复活,测试了几次没发现什么bug,暂且先用这个主题好了.以后研究一下自己学着定制主题吧.","tags":"Python","title":"更换博客主题"},{"url":"http://blog.game18.net/posts/2015/10/li-yong-pelicanhe-github-pagesda-zao-ge-xing-hua-bo-ke-er/","text":"在上一篇里我们已经完成了Pelican的安装,生成网站并部署到GitHub Pages上.下面我们就继续完善网站的设置. 1. 更换主题 目前我们的网站使用默认主题,不是很漂亮,功能也单一,我们首先更换主题.运行: git clone --recursive https://github.com/getpelican/pelican-themes.git 会把所有主题下载到本地,注意使用--recursive参数,否则很多链接的主题只能获取到空文件. 下一步安装主题,有两种方法,在上面的git中提到可以在pelicanconf.py配置文件中指定主题存放路径,如下: THEME = \".../Blog/pelican-themes/theme-name\" 我使用了另一种方法,在pelican-themes文件夹下运行: pelican-themes -i .../Blog/pelican-themes/theme-name 这条命令可以把主题安装到 /Library/Python/2.7/site-packages/pelican/themes 下,然后在配置文件中直接指定主题名即可: THEME = \"theme-name\" 重新 make html ,查看一下是不是已经应用了新的主题. 主题虽然改了,但很多功能还没法使用,我们还需要进行很多配置. 2. 安装插件 插件可以扩展Pelican的功能,很多主题也需要依赖插件运行.和主题的安装一样,首先将插件包下载到本地: git clone --recursive https://github.com/getpelican/pelican-plugins 然后在配置文件中设置插件路径和名称列表: PLUGIN_PATHS = [ 'pelican-plugins' ] PLUGINS = [ 'assets' , 'sitemap' , 'gravatar' ] 简单介绍几个正在用的插件: sitemap 生成sitemap.xml,帮助搜索引擎抓取网站内容.除了添加进插件列表意外,还需要添加一些设置: SITEMAP = { \"format\" : \"xml\" , \"priorities\" : { \"articles\" : 0.7 , \"indexes\" : 0.5 , \"pages\" : 0.3 , }, \"changefreqs\" : { \"articles\" : \"monthly\" , \"indexes\" : \"daily\" , \"pages\" : \"monthly\" , } } render_math 让Pelican支持数学公式,由 MathJax 引擎提供支持,公式语法和LaTex相似,尝试一下: $$E = mc&#94;2$$ tag_cloud 提供 标签云 ,除了显示Tags以外,会按文章数目区分显示不同的标签.这个功能原本是集成在Pelican中的,后来被拿出来作为插件,于是一些旧的主题如果不装这个插件的话标签列表无法显示,例如我尝试使用过的 foundation-default-colours ,安装这个插件就可以解决问题. gzip_cache 将页面压缩为gz格式,提高加载速度. 另外,有些主题需要特定插件的支持,例如我现在用的 elegant 需要安装 extract_toc , tipue_search ,总之查看主题和插件的Readme,自己决定安装哪些插件. 3. 修改配置文件 接下来我们要修改Pelican的配置文件 pelicanconf.py ,这里包含非常多的条目,详细的介绍参见 这里 ,我简单介绍其中几项: 日期格式 DEFAULT_LANG = u'zh' DATE_FORMATS = {'zh' : '%Y-%m-%d(%a)'} 默认的日期格式比较适合国外的习惯,上面两句可以把日期格式改为年-月-日(星期)这样比较适合国人习惯的格式. 文件路径 STATIC_PATHS=[\"imgs\",\"extra\"] EXTRA_PATH_METADATA = { 'extra/CNAME': { 'path': 'CNAME' }, 'extra/favicon.ico': { 'path': 'favicon.ico' }, 'extra/robots.txt': { 'path': 'robots.txt' }, } 我在content目录下建了两个目录 imgs 用来存放图片, extra 里存放了 CNAME,favicon.ico,robots.txt 三个文件.上面两句把imgs文件夹和extra里的三个文件原封不动拷贝到output目录下(注意:imgs是文件夹拷贝,另外三个文件直接拷贝).博文中可以直接使用 ![text](/imgs/filename.jpeg) 这样的链接来引用本地图片.另外三个文件作用分别是: CNAME:解析域名用,后面会说到. favicon.ico:让网页标签中显示图标,像这样 robots.txt:告诉搜索引擎爬虫此网站中的哪些内容不应被搜索引擎获取，哪些可以被获取,写法可以参考 这里 . 文件保存配置 一些主题会要求配置特定的项目,elegant主题推荐如下配置: MD_EXTENSIONS = [ 'codehilite(css_class=highlight)' , 'extra' , 'headerid' , 'toc' ] DIRECT_TEMPLATES = (( 'index' , 'tags' , 'categories' , 'archives' , 'search' , '404' )) TAG_SAVE_AS = '' CATEGORY_SAVE_AS = '' AUTHOR_SAVE_AS = '' 参考官方配置文档可以发现有很多 xxxx_SAVE_AS 的配置项,控制各类页面保存方式,可以使用 {slug} 变量用来获取md文件中的Slug字段.Pelican在保存页面的时候会生成一个文件名,文章名是中文如 随笔 的话会生成类似 sui-bi.html 的文件,同时会过滤掉一些不适合放在路径和文件名中的空格和其他符号.于是带来一个问题,在某些主题中如果添加 C++ 标签的话,保存时会忽略 ++ 生成类似于 ~/tags/c.html 的路径,但是在页面链接中点击 C++ 的tag,网页仍会尝试转向 ~/tags/C++.html 页面,于是报错.elegant主题倒没有这个问题,以后自己定制主题的时候要注意这一点. 其他功能配置: 评论:利用Disqus实现评论功能,只需在配置中添加 DISQUS_SITENAME=\"yoursitename\" Google Analytcs:在配置中添加 GOOGLE_ANALYTICS=\"UA-xxxxxx-xxxx\" 友情链接和社交链接:参照 这里 填写配置文件相关项目 4. Tips 删除线 不是MarkDown的标准语法,使用 ~~ 语法不会被转化为删除线效果,这种情况下可直接使用 <s>删除线</s> . 新建md文件时总是需要在开头写meta data,比较繁琐,我写了一个sh脚本来创建新的md文件,代码如下: #!/bin/sh datetime = $( date +%Y-%m-%d \\ %H:%M:%S ) filename = $( date +%Y%m%d_%H_%M_%S ) echo \"Title: \\nDate: ${ datetime } \\nModified: \\nCategory: \\nTags: \\nSlug: \\nAuthors: \\nSummary: \\nStatus: draft\" >../content/ ${ filename } .md 这样可以自动使用当前日期和时间创建新md文件,而且meta data项目已经都添加好.如果觉得打开shell运行脚本比较麻烦,也可以使用Automator打包成可执行文件(OSX系统).另外,虽然利用 publishconf.py 中的设定可以完成GitHub上传,我还是写了一个脚本完成上传工作: #!/bin/sh commitstr = $( date +%Y%m%d_%H_%M_%S ) cd /Users/lipeng/Documents/Blog make html cd /Users/lipeng/Documents/Blog/output git add . git commit -m ${ commitstr } git push origin master 在脚本中使用 date 获取系统时间,可以确保不会重名,而且上传到GitHub中的commit信息也比较容易识别.我把脚本都扔在tools文件夹中. 使用自己的域名 如果觉得GitHub.io域名不够个性的话,也可以把网站挂在自己的域名下.具体做法是: 在网站根目录新建一个 CNAME 文件(文件名大写,无扩展名),文件中填写域名,我的这个文件中写 blog.game18.net ,将这个文件放在 content/extra 下,按照我们在 这里 的设置, CNAME 文件会被自动拷贝至网站根目录. 登陆域名管理页面,在DNS设定中添加一项: 如果需要做TYPE A设置,参考 这里 将网站同步至GitHub,在根目录下看到 CNAME 文件后,检查Settings页面,应该已显示新域名: 等待几分钟DNS设置生效后即可从新域名访问博客,是不是很酷? 到这里,博客的一些基本设置就完成了,Enjoy your own Blog! if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"Python","title":"利用Pelican和GitHub Pages打造个性化博客(二)"},{"url":"http://blog.game18.net/posts/2015/10/li-yong-pelicanhe-github-pagesda-zao-ge-xing-hua-bo-ke-yi/","text":"1. 配置GitHbu Pages 在GitHub中新建一个repository,命名为username.github.io,其中username是github的用户名,我建的是rocmax.github.io. 进入后点击右边栏中的Settings,找到GitHub Pages栏,点击Launch automatic page generator按钮,然后点击Continue to layouts,选择一个主题样式,点击Publish page,一个崭新的GitHub Pages页面就出现了,你可以使用username.github.io访问这个新页面,是不是很酷? 网页虽然能访问了,但离想要的博客还很遥远.当然,直接去编辑html文件可以改变网页内容,我们显然不会采用这种笨办法.我们先把自动生成的文件都删除(不熟悉Git命令的话可以在网页上挨个删掉然后commit,git命令下面会涉及到) 2. 安装Pelican 我的系统环境: OSX Python Git 10.11 2.7.10 2.3.8 使用pip安装Pelican和MarkDown pip install pelican pip install markdown 如果安装时报Permission denied,在命令前加sodu,运行时可能需要输入系统密码. 在磁盘上新建一个文件夹用来存放本地文件,比如我的文件夹叫Blog,然后运行: cd Blog pelican-quickstart 如果你跟我的环境一样的话 from six.moves.html_parser import HTMLParser 这句代码会报错,在six.moves里找不到html_parser.看来出了一些问题,处理之前我们先卸载Pelican pip uninstall pelican . 网上有一种处理方法是把这句代码改为 from HTMLParser import HTMLParser 实测可以解决. 我在网上找到另一种解释说是因为six的版本过低导致,使用 pip install -U six 可以fetch到新版本但是安装报错,加sudo都不让装,好像说是因为six这个组件比较核心.我找到的解决方法是到 这里 下载six的whl格式安装文件可以正常安装. 然后重新安装Pelican,在Blog下运行 pelican-quickstart ,它会问一些问题,按自己喜好回答或者在 这里 找答案,系统会按照答案生成一些配置,以后可以改所以怎么填都行,完成后会在目录下生成很多文件. 这就是Blog下的文件列表: 解释一下其中的部分内容(有些文件是后面加入的): content 存放md文件 develop_server.sh 控制本地网页服务器 Makefile 生成网站 output 存放生成的网站,之后这个文件夹会被同步到GitHub pelican-plugins 插件目录 pelican-themes 主题目录 pelicanconf.py 配置文件 publishconf.py 发布配置文件 tools 我自己加的,后面再讲 到这里安装就基本完成了. 3. 开始写博客 编写一个md文件,在最前边需要添加一些信息,下面是一个例子: Title : My super title #文章标题 * Date : 2010 - 12 - 03 10 : 20 #编写时间 * Modified : 2010 - 12 - 05 19 : 30 #修改时间 Category : Python #类别 * Tags : pelican , publishing #标签 * Slug : my - super - post #翻译不能 , 链接地址字符串 , 可以用来处理文章不同语言版本 Authors : Alexis Metaireau , Conan Doyle #作者 Summary : Short version for index and feeds #摘要 Hello world !...... 加*的是必填项 写完后放到content目录下,然后在Blog文件夹下执行 make html 生成网站.可以看到output目录下已经存放了生成好的文件. 然后继续运行 make devserver 开启网页服务,浏览器访问http://localhost:8000 即可看到生成的网页了,而且文件更改后还可以实时重新生成.用完以后记得 make stopserver 关闭服务. 4. 将网站部署到GitHub Pages 最后一步,将生成的网站部署到GitHub Pages,这一步需要使用一些Git命令,不熟悉的话请参考 这里 . 在终端里进入output目录,执行下列命令: git init #创建Git仓库 git add . #将output下的所有文件加入仓库 git remote add origin https://github.com/username/username.github.io #添加远程仓库,可能会要求输入Github用户名和密码 git pull origin master #将远程仓库中的文件获取回本地,之前已经都删除了,不会获取任何文件,不这样的话之后提交会冲突 git commit -m 'first update' #提交一个更改,命名为\"first update\" git push origin master #将本地更改同步到远程仓库的master分支 运行完成的话博客就上传到GitHub了,可以登陆username.github.io看一下,应该跟上一步最后看到的网页一样. 总结 到这里就把使用Pelican+GitHub Pages搭建个人博客的基本流程介绍完了.生成的博客应该类似于这样: 呃....好像也很丑的样子,而且也没啥功能. 下一篇我们继续定制这个博客,让它变得既美观又功能强大.","tags":"Python","title":"利用Pelican和GitHub Pages打造个性化博客(一)"},{"url":"http://blog.game18.net/posts/2015/10/zhu-xin-bo-ke-kai-zhang/","text":"生命在于折腾! 不久前刚刚开始使用 Blogger ,为了替换一直使用的印象笔记.用了一段时间发现还是不爽,Blogger对MarkDown的支持并不是太好,也没什么好用的编辑器去配合,而且我费半天劲定制的Blogger界面丑得要死.终于,我下定决心再折腾一遍,搞一个更好用的博客. 上网搜一搜,什么博客比较高大上呢?知乎马上给你答案: GitHub Pages ,GitHub推出了支持静态网页的功能,就是GitHub Pages,程序员当然要用GitHub才算专业嘛.我们现在有md文件写博客内容,只要能把它们转成网页然后发布到GitHub Pages上就大功告成了.在GitHub Pages页面上推荐了 Jekyll 应该是最有名的静态博客网站转换工具.但Jekyll是基于Ruby的,我不懂也不想学,于是我选择了基于Python的 Pelican 来完成这项工作. 经过三天的研究, 新博客 终于上线了,本篇是随笔所以不写太多技术内容,下一篇详细写搭建流程吧. 最后,感谢神奈提供的域名,让博客的 B格 更加提高了一点(刚明明说用GitHub才叫专业).感谢 Talha Mansoor 开发的 Elegant 主题,试过了n多个主题以后,发现Elegant果然是当之无愧的 best-pelican-theme .我自己也研究了一下Pelican的主题开发,似乎难度并不高,以后有时间自己也弄一套吧.另外,感谢Pelican,感谢Python......","tags":"随笔","title":"祝!新博客开张!"}]}